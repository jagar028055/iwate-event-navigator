import { CollectionError } from '../types';

export enum ErrorSeverity {
  LOW = 'minor',
  MEDIUM = 'moderate', 
  HIGH = 'major',
  CRITICAL = 'critical'
}

export enum ErrorCategory {
  NETWORK = 'network',
  API = 'api',
  DATA = 'data',
  SYSTEM = 'system',
  CACHE = 'cache',
  VALIDATION = 'validation'
}

export interface ErrorContext {
  component: string;
  operation: string;
  stage?: number;
  source?: string;
  attemptNumber?: number;
  metadata?: Record<string, any>;
}

export interface RecoveryAction {
  type: 'retry' | 'fallback' | 'skip' | 'fail';
  delay?: number;
  maxAttempts?: number;
  fallbackData?: any;
  reason: string;
}

export interface ErrorPattern {
  pattern: RegExp;
  severity: ErrorSeverity;
  category: ErrorCategory;
  isRetryable: boolean;
  recoveryAction: RecoveryAction;
  description: string;
}

export class ErrorHandler {
  private errorPatterns: ErrorPattern[] = [];
  private errorHistory: CollectionError[] = [];
  private recoveryStrategies: Map<string, RecoveryAction> = new Map();
  private circuitBreakers: Map<string, CircuitBreaker> = new Map();

  constructor() {
    this.initializeErrorPatterns();
    this.initializeRecoveryStrategies();
    console.log('ErrorHandler initialized with comprehensive error patterns');
  }

  private initializeErrorPatterns(): void {
    this.errorPatterns = [
      // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÈñ¢ÈÄ£„Ç®„É©„Éº
      {
        pattern: /network.*error|fetch.*failed|connection.*refused/i,
        severity: ErrorSeverity.HIGH,
        category: ErrorCategory.NETWORK,
        isRetryable: true,
        recoveryAction: {
          type: 'retry',
          delay: 5000,
          maxAttempts: 3,
          reason: 'Network connectivity issue - retryable'
        },
        description: 'Network connectivity or fetch operation failed'
      },

      // APIÂà∂Èôê„Éª„É¨„Éº„ÉàÂà∂Èôê
      {
        pattern: /rate.*limit|too.*many.*requests|quota.*exceeded/i,
        severity: ErrorSeverity.MEDIUM,
        category: ErrorCategory.API,
        isRetryable: true,
        recoveryAction: {
          type: 'retry',
          delay: 60000, // 1ÂàÜÂæÖÊ©ü
          maxAttempts: 2,
          reason: 'Rate limit exceeded - wait and retry'
        },
        description: 'API rate limit or quota exceeded'
      },

      // APIË™çË®º„Ç®„É©„Éº
      {
        pattern: /unauthorized|authentication.*failed|invalid.*key|forbidden/i,
        severity: ErrorSeverity.CRITICAL,
        category: ErrorCategory.API,
        isRetryable: false,
        recoveryAction: {
          type: 'fail',
          reason: 'Authentication failure - requires manual intervention'
        },
        description: 'API authentication or authorization failed'
      },

      // „Çø„Ç§„É†„Ç¢„Ç¶„Éà
      {
        pattern: /timeout|timed.*out/i,
        severity: ErrorSeverity.MEDIUM,
        category: ErrorCategory.NETWORK,
        isRetryable: true,
        recoveryAction: {
          type: 'retry',
          delay: 10000,
          maxAttempts: 2,
          reason: 'Request timeout - retry with longer timeout'
        },
        description: 'Request timeout occurred'
      },

      // JSON„Éë„Éº„Çπ„Ç®„É©„Éº
      {
        pattern: /json.*parse|invalid.*json|unexpected.*token/i,
        severity: ErrorSeverity.HIGH,
        category: ErrorCategory.DATA,
        isRetryable: false,
        recoveryAction: {
          type: 'skip',
          reason: 'Invalid JSON response - skip this data source'
        },
        description: 'JSON parsing failed due to invalid response format'
      },

      // „Éá„Éº„ÇøÊ§úË®º„Ç®„É©„Éº
      {
        pattern: /validation.*failed|invalid.*event|missing.*required/i,
        severity: ErrorSeverity.LOW,
        category: ErrorCategory.VALIDATION,
        isRetryable: false,
        recoveryAction: {
          type: 'skip',
          reason: 'Data validation failed - skip invalid entries'
        },
        description: 'Event data validation failed'
      },

      // „Ç≠„É£„ÉÉ„Ç∑„É•„Ç®„É©„Éº
      {
        pattern: /cache.*error|storage.*full|quota.*exceeded.*storage/i,
        severity: ErrorSeverity.MEDIUM,
        category: ErrorCategory.CACHE,
        isRetryable: false,
        recoveryAction: {
          type: 'fallback',
          reason: 'Cache operation failed - proceed without caching'
        },
        description: 'Cache operation failed'
      },

      // „Ç∑„Çπ„ÉÜ„É†„É™„ÇΩ„Éº„Çπ„Ç®„É©„Éº
      {
        pattern: /out.*of.*memory|memory.*limit|resource.*exhausted/i,
        severity: ErrorSeverity.CRITICAL,
        category: ErrorCategory.SYSTEM,
        isRetryable: false,
        recoveryAction: {
          type: 'fail',
          reason: 'System resource exhaustion - requires intervention'
        },
        description: 'System resource exhaustion'
      }
    ];
  }

  private initializeRecoveryStrategies(): void {
    // StageÂà•„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊà¶Áï•
    this.recoveryStrategies.set('stage-1-fallback', {
      type: 'fallback',
      fallbackData: [], // Á©∫„ÅÆÈÖçÂàó„Åß„ÇÇÂá¶ÁêÜ„ÅØÁ∂ôÁ∂ö
      reason: 'Stage 1 fallback - use cached data or skip'
    });

    this.recoveryStrategies.set('stage-2-fallback', {
      type: 'retry',
      delay: 30000,
      maxAttempts: 1,
      reason: 'Stage 2 fallback - retry once with reduced scope'
    });

    this.recoveryStrategies.set('stage-3-fallback', {
      type: 'skip',
      reason: 'Stage 3 fallback - skip category collection'
    });
  }

  public async handleError(
    error: Error,
    context: ErrorContext
  ): Promise<RecoveryAction> {
    // „Ç®„É©„Éº„ÇíÂ±•Ê≠¥„Å´Ë®òÈå≤
    const collectionError = this.createCollectionError(error, context);
    this.errorHistory.push(collectionError);
    this.pruneErrorHistory();

    // „Ç®„É©„Éº„Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„É≥„Ç∞
    const matchedPattern = this.matchErrorPattern(error.message);
    
    // „Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„Éº„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
    const circuitBreakerAction = this.checkCircuitBreaker(context.component, error);
    if (circuitBreakerAction) {
      console.log(`üîí Circuit breaker activated for ${context.component}`);
      return circuitBreakerAction;
    }

    // ÈÅ©Âàá„Å™„É™„Ç´„Éê„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊ±∫ÂÆö
    let recoveryAction: RecoveryAction;

    if (matchedPattern) {
      recoveryAction = { ...matchedPattern.recoveryAction };
      console.log(`üîç Error pattern matched: ${matchedPattern.description}`);
    } else {
      recoveryAction = this.getDefaultRecoveryAction(error, context);
      console.log(`‚ùì Unknown error pattern, using default recovery`);
    }

    // „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Å´Âü∫„Å•„ÅÑ„ÅüË™øÊï¥
    recoveryAction = this.adjustRecoveryForContext(recoveryAction, context);

    // „Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„Éº„ÅÆÁä∂ÊÖãÊõ¥Êñ∞
    this.updateCircuitBreaker(context.component, error, recoveryAction.type === 'retry');

    console.log(`üö® Error handled: ${error.message}`);
    console.log(`üí° Recovery action: ${recoveryAction.type} - ${recoveryAction.reason}`);

    return recoveryAction;
  }

  private createCollectionError(error: Error, context: ErrorContext): CollectionError {
    const matchedPattern = this.matchErrorPattern(error.message);
    
    return {
      severity: matchedPattern?.severity || ErrorSeverity.MEDIUM,
      source: context.source || context.component,
      message: error.message,
      timestamp: new Date(),
      retryable: matchedPattern?.isRetryable ?? false
    };
  }

  private matchErrorPattern(errorMessage: string): ErrorPattern | null {
    return this.errorPatterns.find(pattern => 
      pattern.pattern.test(errorMessage)
    ) || null;
  }

  private getDefaultRecoveryAction(error: Error, context: ErrorContext): RecoveryAction {
    // „Éá„Éï„Ç©„É´„Éà„ÅÆ„É™„Ç´„Éê„É™Êà¶Áï•
    if (context.stage === 1) {
      return {
        type: 'retry',
        delay: 10000,
        maxAttempts: 2,
        reason: 'Default retry for critical Stage 1'
      };
    }

    if (context.stage === 2) {
      return {
        type: 'skip',
        reason: 'Default skip for Stage 2 - not critical'
      };
    }

    return {
      type: 'skip',
      reason: 'Default skip for unknown error'
    };
  }

  private adjustRecoveryForContext(
    action: RecoveryAction, 
    context: ErrorContext
  ): RecoveryAction {
    const adjustedAction = { ...action };

    // Ë©¶Ë°åÂõûÊï∞„Å´„Çà„ÇãË™øÊï¥
    if (context.attemptNumber && context.attemptNumber > 2) {
      // 3Âõû‰ª•‰∏äÂ§±Êïó„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØË´¶„ÇÅ„Çã
      adjustedAction.type = 'skip';
      adjustedAction.reason = `Too many attempts (${context.attemptNumber}) - giving up`;
    }

    // StageÂà•„ÅÆÈáçË¶ÅÂ∫¶„Å´„Çà„ÇãË™øÊï¥
    if (context.stage === 1 && action.type === 'skip') {
      // Stage 1„ÅØÈáçË¶Å„Å™„ÅÆ„Åß„Çπ„Ç≠„ÉÉ„Éó„Çí„É™„Éà„É©„Ç§„Å´Â§âÊõ¥
      adjustedAction.type = 'retry';
      adjustedAction.delay = 15000;
      adjustedAction.maxAttempts = 1;
      adjustedAction.reason = 'Stage 1 is critical - retry once more';
    }

    // ÊôÇÈñìÂ∏Ø„Å´„Çà„ÇãË™øÊï¥
    const hour = new Date().getHours();
    if (hour >= 2 && hour <= 6 && adjustedAction.delay) {
      // Ê∑±Â§úÊôÇÈñìÂ∏Ø„ÅØ„É™„Éà„É©„Ç§ÈñìÈöî„ÇíÁü≠Á∏Æ
      adjustedAction.delay = Math.max(adjustedAction.delay * 0.5, 1000);
      adjustedAction.reason += ' (reduced delay for off-peak hours)';
    }

    return adjustedAction;
  }

  // „Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„Éº„Éë„Çø„Éº„É≥ÂÆüË£Ö
  private checkCircuitBreaker(component: string, error: Error): RecoveryAction | null {
    const circuitBreaker = this.circuitBreakers.get(component);
    
    if (!circuitBreaker) {
      // Êñ∞„Åó„ÅÑ„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„Éº„Çí‰ΩúÊàê
      this.circuitBreakers.set(component, new CircuitBreaker(component));
      return null;
    }

    if (circuitBreaker.isOpen()) {
      return {
        type: 'skip',
        reason: `Circuit breaker open for ${component} - too many recent failures`
      };
    }

    return null;
  }

  private updateCircuitBreaker(component: string, error: Error, willRetry: boolean): void {
    let circuitBreaker = this.circuitBreakers.get(component);
    
    if (!circuitBreaker) {
      circuitBreaker = new CircuitBreaker(component);
      this.circuitBreakers.set(component, circuitBreaker);
    }

    if (willRetry) {
      circuitBreaker.recordFailure();
    } else {
      circuitBreaker.recordSuccess(); // „Çπ„Ç≠„ÉÉ„Éó„ÇÇ‰∏ÄÁ®Æ„ÅÆ„ÄåÊàêÂäü„Äç„Å®„Åó„Å¶Êâ±„ÅÜ
    }
  }

  // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Éá„Éº„ÇøÂèñÂæó
  public async getFallbackData(context: ErrorContext): Promise<any> {
    console.log(`üîÑ Getting fallback data for ${context.component}`);
    
    try {
      // „Ç≠„É£„ÉÉ„Ç∑„É•„Åï„Çå„Åü„Éá„Éº„Çø„ÇíË©¶Ë°å
      const cachedData = await this.getCachedFallbackData(context);
      if (cachedData) {
        console.log('‚úÖ Using cached fallback data');
        return cachedData;
      }

      // ÈùôÁöÑ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Éá„Éº„Çø
      const staticData = await this.getStaticFallbackData(context);
      if (staticData) {
        console.log('‚úÖ Using static fallback data');
        return staticData;
      }

      console.log('‚ö†Ô∏è No fallback data available');
      return null;

    } catch (error) {
      console.error('‚ùå Fallback data retrieval failed:', error);
      return null;
    }
  }

  private async getCachedFallbackData(context: ErrorContext): Promise<any> {
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÈÅéÂéª„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó
    try {
      // ÂÆüË£ÖÊôÇ„Å´„ÅØeventCache„Åã„ÇâÈÅéÂéª„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó
      return null; // „Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº
    } catch {
      return null;
    }
  }

  private async getStaticFallbackData(context: ErrorContext): Promise<any> {
    // ÈùôÁöÑ„Å™„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Éá„Éº„ÇøÔºàÈáçË¶Å„Å™Âπ¥‰∏≠Ë°å‰∫ã„Å™„Å©Ôºâ
    if (context.stage === 1) {
      return [
        {
          id: 'fallback-001',
          title: 'ÁõõÂ≤°„Åï„Çì„ÅïË∏ä„Çä',
          description: 'ÁõõÂ≤°„ÅÆÂ§è„ÇíÂΩ©„Çã‰ºùÁµ±ÁöÑ„Å™Á•≠„ÇäÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Éá„Éº„ÇøÔºâ',
          date: '2024-08-01',
          locationName: 'ÁõõÂ≤°Â∏Ç‰∏≠Â§ÆÈÄö',
          latitude: 39.7036,
          longitude: 141.1527,
          category: 'Á•≠„Çä'
        }
      ];
    }

    return [];
  }

  // „Ç®„É©„ÉºÁµ±Ë®à„ÉªÂàÜÊûêÊ©üËÉΩ
  public getErrorStatistics(): {
    totalErrors: number;
    errorsBySeverity: { [key in ErrorSeverity]: number };
    errorsByCategory: { [key in ErrorCategory]: number };
    topErrors: { message: string; count: number }[];
    recentTrends: {
      hourly: number[];
      daily: number[];
    };
  } {
    const now = new Date();
    const last24Hours = this.errorHistory.filter(
      error => now.getTime() - error.timestamp.getTime() < 24 * 60 * 60 * 1000
    );

    const errorsBySeverity = {
      [ErrorSeverity.LOW]: 0,
      [ErrorSeverity.MEDIUM]: 0,
      [ErrorSeverity.HIGH]: 0,
      [ErrorSeverity.CRITICAL]: 0
    };

    const errorsByCategory = {
      [ErrorCategory.NETWORK]: 0,
      [ErrorCategory.API]: 0,
      [ErrorCategory.DATA]: 0,
      [ErrorCategory.SYSTEM]: 0,
      [ErrorCategory.CACHE]: 0,
      [ErrorCategory.VALIDATION]: 0
    };

    // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÈõÜË®à
    const errorMessages = new Map<string, number>();
    
    for (const error of last24Hours) {
      errorsBySeverity[error.severity as ErrorSeverity]++;
      
      // „Ç´„ÉÜ„Ç¥„É™„ÅØÊé®ÂÆö
      const pattern = this.matchErrorPattern(error.message);
      if (pattern) {
        errorsByCategory[pattern.category]++;
      }

      // „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Ç´„Ç¶„É≥„Éà
      const shortMessage = error.message.substring(0, 100);
      errorMessages.set(shortMessage, (errorMessages.get(shortMessage) || 0) + 1);
    }

    // „Éà„ÉÉ„Éó„Ç®„É©„Éº„ÅÆË®àÁÆó
    const topErrors = Array.from(errorMessages.entries())
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([message, count]) => ({ message, count }));

    return {
      totalErrors: last24Hours.length,
      errorsBySeverity,
      errorsByCategory,
      topErrors,
      recentTrends: {
        hourly: this.calculateHourlyTrends(last24Hours),
        daily: this.calculateDailyTrends()
      }
    };
  }

  private calculateHourlyTrends(errors: CollectionError[]): number[] {
    const hourlyCount = new Array(24).fill(0);
    const now = new Date();

    for (const error of errors) {
      const hoursAgo = Math.floor((now.getTime() - error.timestamp.getTime()) / (60 * 60 * 1000));
      if (hoursAgo < 24) {
        hourlyCount[23 - hoursAgo]++;
      }
    }

    return hourlyCount;
  }

  private calculateDailyTrends(): number[] {
    // ÈÅéÂéª7Êó•Èñì„ÅÆ„Ç®„É©„ÉºÊï∞
    const dailyCount = new Array(7).fill(0);
    const now = new Date();

    for (const error of this.errorHistory) {
      const daysAgo = Math.floor((now.getTime() - error.timestamp.getTime()) / (24 * 60 * 60 * 1000));
      if (daysAgo < 7) {
        dailyCount[6 - daysAgo]++;
      }
    }

    return dailyCount;
  }

  private pruneErrorHistory(): void {
    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7Êó•Èñì
    const cutoff = Date.now() - maxAge;
    
    this.errorHistory = this.errorHistory.filter(
      error => error.timestamp.getTime() > cutoff
    );
  }

  // „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
  public getHealthStatus(): {
    isHealthy: boolean;
    issues: string[];
    recommendations: string[];
    circuitBreakerStatus: { component: string; isOpen: boolean; failureRate: number }[];
  } {
    const issues: string[] = [];
    const recommendations: string[] = [];

    // ÊúÄËøë„ÅÆ„Ç®„É©„ÉºÁéá„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    const recentErrors = this.errorHistory.filter(
      error => Date.now() - error.timestamp.getTime() < 60 * 60 * 1000 // 1ÊôÇÈñì‰ª•ÂÜÖ
    );

    const criticalErrors = recentErrors.filter(
      error => error.severity === ErrorSeverity.CRITICAL
    ).length;

    if (criticalErrors > 0) {
      issues.push(`${criticalErrors} critical errors in the last hour`);
      recommendations.push('Review critical errors and consider manual intervention');
    }

    const highErrors = recentErrors.filter(
      error => error.severity === ErrorSeverity.HIGH
    ).length;

    if (highErrors > 5) {
      issues.push(`${highErrors} high-severity errors in the last hour`);
      recommendations.push('Monitor error patterns and consider adjusting retry strategies');
    }

    // „Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÁä∂ÊÖã
    const circuitBreakerStatus = Array.from(this.circuitBreakers.entries()).map(
      ([component, breaker]) => ({
        component,
        isOpen: breaker.isOpen(),
        failureRate: breaker.getFailureRate()
      })
    );

    const openBreakers = circuitBreakerStatus.filter(status => status.isOpen);
    if (openBreakers.length > 0) {
      issues.push(`${openBreakers.length} circuit breakers are open`);
      recommendations.push('Wait for circuit breakers to reset or investigate underlying issues');
    }

    return {
      isHealthy: issues.length === 0,
      issues,
      recommendations,
      circuitBreakerStatus
    };
  }
}

// „Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÂÆüË£Ö
class CircuitBreaker {
  private failureCount = 0;
  private successCount = 0;
  private lastFailureTime?: Date;
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  
  private readonly failureThreshold = 5;
  private readonly timeout = 60000; // 1ÂàÜ
  private readonly successThreshold = 2;

  constructor(private component: string) {}

  public recordFailure(): void {
    this.failureCount++;
    this.lastFailureTime = new Date();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'open';
      console.log(`üîí Circuit breaker opened for ${this.component}`);
    }
  }

  public recordSuccess(): void {
    this.successCount++;
    
    if (this.state === 'half-open' && this.successCount >= this.successThreshold) {
      this.state = 'closed';
      this.failureCount = 0;
      this.successCount = 0;
      console.log(`‚úÖ Circuit breaker closed for ${this.component}`);
    }
  }

  public isOpen(): boolean {
    if (this.state === 'open' && this.lastFailureTime) {
      const now = Date.now();
      if (now - this.lastFailureTime.getTime() > this.timeout) {
        this.state = 'half-open';
        console.log(`üîì Circuit breaker half-open for ${this.component}`);
        return false;
      }
    }
    
    return this.state === 'open';
  }

  public getFailureRate(): number {
    const total = this.failureCount + this.successCount;
    return total > 0 ? this.failureCount / total : 0;
  }
}