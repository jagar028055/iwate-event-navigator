# 岩手イベントナビゲーター - 定期更新・キャッシングシステム設計書

## 1. システム概要

### 1.1 目的
- リアルタイムに近いイベント情報更新
- ユーザー体験の向上（高速レスポンス）
- API使用量の最適化
- システム負荷の分散

### 1.2 設計原則
- **段階的更新**: 重要度・緊急度別の更新頻度
- **インクリメンタル更新**: 差分のみの効率的更新
- **フォールバック機能**: 障害時の代替データ提供
- **リソース最適化**: メモリ・ストレージ使用量の最適化

## 2. 更新スケジュール設計

### 2.1 更新頻度マトリックス

```javascript
const UPDATE_SCHEDULE = {
  // 毎日更新（高優先度）
  daily: {
    time: "06:00",
    targets: [
      "新規イベント差分取得",
      "当日・翌日イベント詳細更新",
      "緊急変更・中止情報"
    ],
    estimatedDuration: "15分",
    apiCalls: 20
  },
  
  // 隔日更新（市町村ローテーション）
  alternateDays: {
    time: "02:00",
    targets: [
      "市町村別詳細収集（11自治体/回）",
      "地域密着イベント更新"
    ],
    cycle: "3日で全33市町村完了",
    estimatedDuration: "45分",
    apiCalls: 50
  },
  
  // 週1回更新（全件検証）
  weekly: {
    time: "日曜 01:00",
    targets: [
      "全イベント再検証",
      "重複排除処理",
      "データクレンジング",
      "キャッシュ最適化"
    ],
    estimatedDuration: "2時間",
    apiCalls: 100
  },
  
  // 月1回更新（システムメンテナンス）
  monthly: {
    time: "第1日曜 00:00",
    targets: [
      "情報源リスト更新",
      "パフォーマンス分析",
      "ストレージ最適化",
      "統計データ生成"
    ],
    estimatedDuration: "3時間",
    maintenanceWindow: true
  }
};
```

### 2.2 動的スケジューリング

```typescript
interface DynamicSchedule {
  eventDensity: 'high' | 'medium' | 'low';
  seasonalFactor: number; // 0.5-2.0
  userActivity: number; // アクティブユーザー数
  adjustedFrequency: {
    daily: number; // 基準値からの倍率
    alternateDay: number;
    weekly: number;
  };
}

// 祭りシーズン（7-10月）の頻度調整例
const FESTIVAL_SEASON_ADJUSTMENT = {
  daily: 1.5, // 1.5倍の頻度
  alternateDay: 2.0, // 2倍の頻度
  weekly: 1.0 // 変更なし
};
```

## 3. キャッシングシステム設計

### 3.1 多層キャッシュ構造

```typescript
// Layer 1: メモリキャッシュ（最高速）
interface MemoryCache {
  hotData: Map<string, EventInfo>; // 今日・明日のイベント
  userFilters: Map<string, FilteredResult>; // ユーザー別フィルタ結果
  geoData: Map<string, GeocodedLocation>; // 地理情報
  maxSize: 50; // MB
  ttl: 3600; // 1時間
}

// Layer 2: LocalStorageキャッシュ（高速）
interface LocalStorageCache {
  recentSearches: SearchHistory[];
  userPreferences: UserSettings;
  favoriteEvents: EventInfo[];
  maxSize: 10; // MB
  ttl: 86400; // 24時間
}

// Layer 3: IndexedDBキャッシュ（大容量）
interface IndexedDBCache {
  allEvents: EventInfo[]; // 全イベントデータ
  historicalData: HistoricalEvent[]; // 過去のイベント
  sourceMetadata: SourceInfo[]; // 情報源メタデータ
  maxSize: 100; // MB
  ttl: 604800; // 7日間
}
```

### 3.2 キャッシュ戦略

```typescript
class CacheStrategy {
  // LRU (Least Recently Used) + TTL (Time To Live)
  private lruTtlStrategy = {
    evictionPolicy: 'lru-ttl',
    maxEntries: 1000,
    ttlSeconds: 3600,
    cleanupInterval: 300 // 5分毎クリーンアップ
  };

  // 地理的近接性ベースキャッシュ
  private geographicalCache = {
    userLocation: [latitude, longitude],
    radiusKm: 50,
    priorityWeight: 0.8 // 近いイベントほど長時間キャッシュ
  };

  // カテゴリ別キャッシュ重み付け
  private categoryWeights = {
    'urgent': 0.1,    // 緊急情報（短TTL）
    'festival': 0.7,  // 祭り（長TTL）
    'daily': 0.3,     // 日常的イベント（中TTL）
    'seasonal': 0.9   // 季節イベント（最長TTL）
  };
}
```

## 4. UpdateScheduler実装仕様

### 4.1 スケジューラーコア

```typescript
class UpdateScheduler {
  private jobs: Map<string, ScheduledJob> = new Map();
  private isRunning: boolean = false;
  private currentJobs: Set<string> = new Set();

  async start() {
    this.isRunning = true;
    this.setupCronJobs();
    this.startJobMonitoring();
  }

  private setupCronJobs() {
    // 毎日6時: 新規イベント取得
    this.scheduleJob('daily-update', '0 6 * * *', 
      () => this.executeDailyUpdate());
    
    // 隔日2時: 市町村別更新
    this.scheduleJob('municipal-rotation', '0 2 */2 * *', 
      () => this.executeMunicipalUpdate());
    
    // 日曜1時: 週次全件更新
    this.scheduleJob('weekly-full', '0 1 * * 0', 
      () => this.executeWeeklyUpdate());
  }

  private async executeDailyUpdate(): Promise<UpdateResult> {
    const startTime = Date.now();
    try {
      // 1. 緊急情報チェック
      const urgentUpdates = await this.checkUrgentUpdates();
      
      // 2. 当日イベント詳細更新
      const todayUpdates = await this.updateTodayEvents();
      
      // 3. 新規イベント差分取得
      const newEvents = await this.fetchNewEvents();
      
      // 4. キャッシュ更新
      await this.updateCache([...urgentUpdates, ...todayUpdates, ...newEvents]);
      
      return {
        status: 'success',
        duration: Date.now() - startTime,
        processedEvents: urgentUpdates.length + todayUpdates.length + newEvents.length,
        apiCallsUsed: this.getApiCallCount()
      };
    } catch (error) {
      return this.handleUpdateError('daily-update', error);
    }
  }
}
```

### 4.2 JobQueue管理

```typescript
class JobQueue {
  private queue: PriorityQueue<Job> = new PriorityQueue();
  private workers: Worker[] = [];
  private maxConcurrency: number = 3;

  async enqueue(job: Job): Promise<string> {
    const jobId = crypto.randomUUID();
    job.id = jobId;
    job.enqueueTime = Date.now();
    
    // 優先度計算
    job.priority = this.calculatePriority(job);
    
    this.queue.enqueue(job);
    this.processQueue();
    
    return jobId;
  }

  private calculatePriority(job: Job): number {
    let priority = 0;
    
    // タイプ別基本優先度
    const typePriority = {
      'urgent': 100,
      'daily': 50,
      'municipal': 30,
      'weekly': 10
    };
    
    priority += typePriority[job.type] || 0;
    
    // 時間要因（遅延ペナルティ）
    const delayMinutes = (Date.now() - job.scheduledTime) / (1000 * 60);
    if (delayMinutes > 0) {
      priority += Math.min(delayMinutes * 2, 50);
    }
    
    return priority;
  }

  private async processQueue(): Promise<void> {
    while (this.workers.length < this.maxConcurrency && !this.queue.isEmpty()) {
      const job = this.queue.dequeue();
      if (job) {
        const worker = new JobWorker(job);
        this.workers.push(worker);
        
        worker.execute()
          .then(result => this.handleJobComplete(worker, result))
          .catch(error => this.handleJobError(worker, error));
      }
    }
  }
}
```

## 5. エラーハンドリング・フォールバック

### 5.1 障害レベル分類

```typescript
enum FailureLevel {
  MINOR = 'minor',     // 一部データ取得失敗
  MODERATE = 'moderate', // 特定ソース全体失敗
  MAJOR = 'major',     // システム全体影響
  CRITICAL = 'critical' // サービス停止レベル
}

class FailureHandler {
  async handle(error: Error, level: FailureLevel): Promise<RecoveryAction> {
    switch (level) {
      case FailureLevel.MINOR:
        return this.handleMinorFailure(error);
      case FailureLevel.MODERATE:
        return this.handleModerateFailure(error);
      case FailureLevel.MAJOR:
        return this.handleMajorFailure(error);
      case FailureLevel.CRITICAL:
        return this.handleCriticalFailure(error);
    }
  }

  private async handleMinorFailure(error: Error): Promise<RecoveryAction> {
    // ログ出力のみ、処理継続
    console.warn('Minor update failure:', error.message);
    return { action: 'continue', retryAfter: null };
  }

  private async handleModerateFailure(error: Error): Promise<RecoveryAction> {
    // 5分後リトライ、3回失敗でスキップ
    return { 
      action: 'retry', 
      retryAfter: 300000, // 5分
      maxRetries: 3,
      fallbackData: await this.getCachedData()
    };
  }
}
```

### 5.2 フォールバックデータ提供

```typescript
class FallbackService {
  private staticEventData: EventInfo[] = [
    // 年中行事的なイベント（固定日程）
    {
      id: 'static-001',
      title: '盛岡さんさ踊り',
      date: '2024-08-01',
      locationName: '盛岡市中央通',
      // ... 基本情報
    }
  ];

  async provideFallbackEvents(): Promise<EventInfo[]> {
    // 1. キャッシュデータ確認
    const cachedEvents = await this.getCachedEvents();
    if (cachedEvents.length > 0) {
      return this.filterValidEvents(cachedEvents);
    }

    // 2. 静的データ提供
    return this.staticEventData.filter(event => 
      new Date(event.date) >= new Date()
    );
  }

  private filterValidEvents(events: EventInfo[]): EventInfo[] {
    const now = new Date();
    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    
    return events.filter(event => 
      new Date(event.date) > oneWeekAgo
    );
  }
}
```

## 6. パフォーマンス監視

### 6.1 メトリクス収集

```typescript
interface PerformanceMetrics {
  updateCycles: {
    daily: CycleMetrics;
    municipal: CycleMetrics;
    weekly: CycleMetrics;
  };
  cacheHitRate: number;
  apiUsage: {
    callsPerDay: number;
    averageResponseTime: number;
    errorRate: number;
  };
  systemHealth: {
    memoryUsage: number;
    storageUsage: number;
    cpuUsage: number;
  };
}

interface CycleMetrics {
  averageDuration: number;
  successRate: number;
  eventsProcessed: number;
  lastExecutionTime: Date;
}
```

### 6.2 自動最適化

```typescript
class PerformanceOptimizer {
  async optimize(): Promise<OptimizationReport> {
    const metrics = await this.collectMetrics();
    const recommendations: OptimizationAction[] = [];

    // キャッシュヒット率が低い場合
    if (metrics.cacheHitRate < 0.7) {
      recommendations.push({
        type: 'cache-optimization',
        action: 'increase-cache-size',
        details: 'キャッシュサイズを20%増加'
      });
    }

    // API呼び出しが多い場合
    if (metrics.apiUsage.callsPerDay > 300) {
      recommendations.push({
        type: 'api-optimization',
        action: 'reduce-call-frequency',
        details: '低優先度更新の頻度を50%削減'
      });
    }

    return { metrics, recommendations };
  }
}
```

## 7. 設定・運用

### 7.1 環境設定

```typescript
interface SchedulerConfig {
  development: {
    updateFrequency: 'manual', // 開発時は手動更新
    cacheSize: 'small',
    apiRateLimit: 10 // calls/hour
  };
  production: {
    updateFrequency: 'automatic',
    cacheSize: 'large',
    apiRateLimit: 1000 // calls/day
  };
  maintenance: {
    updateFrequency: 'disabled',
    cacheSize: 'minimal',
    fallbackOnly: true
  };
}
```

### 7.2 管理機能

```typescript
class SchedulerAdmin {
  // 手動更新トリガー
  async triggerManualUpdate(type: UpdateType): Promise<void> {
    const job = new ManualJob(type);
    await this.jobQueue.enqueue(job);
  }

  // 統計情報表示
  async getStatistics(): Promise<SystemStatistics> {
    return {
      totalEvents: await this.eventCount(),
      lastUpdateTime: this.getLastUpdateTime(),
      cacheStatus: await this.getCacheStatus(),
      upcomingJobs: this.getScheduledJobs()
    };
  }

  // 緊急停止
  async emergencyStop(): Promise<void> {
    this.scheduler.stop();
    this.jobQueue.clear();
    await this.notifyAdministrators('System stopped for emergency maintenance');
  }
}
```

この設計により、効率的で信頼性の高い定期更新システムが構築され、ユーザーに常に最新のイベント情報を提供できます。