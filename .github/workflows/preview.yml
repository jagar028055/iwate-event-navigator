name: Preview Deployment

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pages: write
  id-token: write
  pull-requests: write
  issues: write

concurrency:
  group: "preview-${{ github.event.number }}"
  cancel-in-progress: true

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Check Environment Variables
      run: |
        echo "Checking environment variables for preview..."
        echo "GEMINI_API_KEY exists: ${{ secrets.GEMINI_API_KEY != '' }}"
        if [ -n "${{ secrets.GEMINI_API_KEY }}" ]; then
          echo "GEMINI_API_KEY is set for preview"
        else
          echo "‚ö†Ô∏è GEMINI_API_KEY is not set for preview, using test key"
        fi
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        
    - name: Build
      run: npm run build
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY || 'TEST_KEY_FOR_PREVIEW' }}
        VITE_GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY || 'TEST_KEY_FOR_PREVIEW' }}
        
    - name: Install Playwright Browsers
      run: |
        npx playwright install --with-deps chromium
        # Verify installation
        npx playwright --version
      
    - name: Start preview server
      run: |
        npm run preview &
        echo "Waiting for server to start..."
        sleep 30
        
        # Health check to ensure server is ready
        for i in {1..10}; do
          if curl -f http://localhost:4173 >/dev/null 2>&1; then
            echo "Server is ready!"
            break
          else
            echo "Attempt $i: Server not ready, waiting..."
            sleep 5
          fi
        done
        
    - name: Run Playwright tests
      run: npm run test
      env:
        BASE_URL: http://localhost:4173
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        CI: true
        
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: preview-test-results-${{ github.event.number }}
        path: |
          playwright-report/
          test-results/
        retention-days: 7
        
    - name: Evaluate test results and comment
      if: always()
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          
          let testSummary = '## üß™ Preview Test Results\n\n';
          let deploymentDecision = 'proceed';
          
          try {
            const resultsPath = 'test-results/results.json';
            if (fs.existsSync(resultsPath)) {
              const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
              const stats = results.stats;
              
              testSummary += `### Test Statistics\n`;
              testSummary += `- ‚úÖ **Passed**: ${stats.passed}\n`;
              testSummary += `- ‚ùå **Failed**: ${stats.failed}\n`;
              testSummary += `- ‚è≠Ô∏è **Skipped**: ${stats.skipped}\n`;
              testSummary += `- üìä **Total**: ${stats.total}\n\n`;
              
              // Critical test analysis
              const criticalTests = [
                '„Éö„Éº„Ç∏„ÅåÊ≠£Â∏∏„Å´Ë™≠„ÅøËæº„Åæ„Çå„Çã',
                'JavaScript„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å™„ÅÑ', 
                'Áí∞Â¢ÉÂ§âÊï∞„ÅÆÊ≠£„Åó„ÅÑË®≠ÂÆöÁ¢∫Ë™ç',
                '„É¨„Çπ„Éù„É≥„Ç∑„Éñ„Éá„Ç∂„Ç§„É≥„ÅåÊ©üËÉΩ„Åô„Çã'
              ];
              
              const failedTests = results.suites
                .flatMap(suite => suite.specs || [])
                .filter(spec => spec.tests?.some(test => test.status === 'failed'))
                .map(spec => spec.title);
              
              const criticalFailures = failedTests.filter(test => 
                criticalTests.some(critical => test.includes(critical))
              );
              
              if (criticalFailures.length > 0) {
                testSummary += `### ‚ùå Critical Test Failures\n`;
                criticalFailures.forEach(test => {
                  testSummary += `- ${test}\n`;
                });
                testSummary += `\nüö´ **Preview deployment blocked due to critical test failures**\n\n`;
                deploymentDecision = 'blocked';
              } else if (stats.failed > 0) {
                testSummary += `### ‚ö†Ô∏è Non-Critical Test Failures\n`;
                failedTests.forEach(test => {
                  testSummary += `- ${test}\n`;
                });
                testSummary += `\n‚úÖ **Preview deployment approved with warnings**\n\n`;
                deploymentDecision = 'warning';
              } else {
                testSummary += `### üéâ All Tests Passed\n`;
                testSummary += `‚úÖ **Preview deployment approved**\n\n`;
                deploymentDecision = 'success';
              }
            } else {
              testSummary += `‚ö†Ô∏è Test results file not found\n\n`;
            }
          } catch (error) {
            testSummary += `‚ö†Ô∏è Error reading test results: ${error.message}\n\n`;
          }
          
          // Add deployment instructions
          if (deploymentDecision === 'proceed' || deploymentDecision === 'warning' || deploymentDecision === 'success') {
            testSummary += `### üöÄ Preview Deployment\n`;
            testSummary += `Preview environment will be available after merge.\n`;
            testSummary += `- **Build artifacts**: Available in workflow artifacts\n`;
            testSummary += `- **Test reports**: Available in workflow artifacts\n\n`;
          }
          
          testSummary += `### üìä Workflow Details\n`;
          testSummary += `- **Commit**: ${context.payload.pull_request.head.sha.substring(0, 7)}\n`;
          testSummary += `- **Branch**: \`${context.payload.pull_request.head.ref}\`\n`;
          testSummary += `- **Workflow**: [View Details](${context.payload.repository.html_url}/actions/runs/${context.runId})\n`;
          
          // Comment on PR
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: testSummary
          });
          
          // Set output for potential use in other jobs
          core.setOutput('deployment_decision', deploymentDecision);
          
          // Fail the workflow if critical tests failed
          if (deploymentDecision === 'blocked') {
            core.setFailed('Critical tests failed - blocking preview deployment');
          }

  cleanup-on-close:
    runs-on: ubuntu-latest
    if: github.event.action == 'closed'
    
    steps:
    - name: Cleanup Preview Resources
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          // Add cleanup logic here if needed
          // For now, just add a comment that preview was cleaned up
          if (context.payload.pull_request.merged) {
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## üßπ Preview Cleanup\n\nPR merged successfully! Preview resources have been cleaned up.\n\n‚úÖ Changes deployed to production environment.`
            });
          } else {
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## üßπ Preview Cleanup\n\nPR closed. Preview resources have been cleaned up.`
            });
          }